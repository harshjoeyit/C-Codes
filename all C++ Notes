std::sort - 

A hybrid sorting algorithm provides average and worst case time complexity of O(nlogn). The sorting algorithm which it uses is called Introsort.
Introsort is combination of both quicksort and heapsort, It begins with quicksort and switch to heapsort if recursion depth exceeds a level based on the number of elements being sorted.

sort() function usually uses Introsort. Therefore, sort() may preserve the physical order of semantically equivalent values but can’t be guaranteed.

stable_sort() function usually uses mergesort. Therefore, stable_sort() preserve the physical order of semantically equivalent values and its guaranteed.




cross initialization error -

Occurs when variables are declared in case in the switch.
To remove error use a block {} to enclose the variables declared. 




container adapters-

both stack and queues are container adapters and implemented on deque
priorirty queue is implemented on a vector 




minimum required to compile a file -

int main() { }




Statement

We know that every statement in C++ must end with a semicolon. However, unlike other languages, almost all statements in C++ can be treated as expressions. So, if we place the statement inside an if statement with a blank pair of parentheses, we don’t have to end it with a semicolon anymore.

if (a = 1) {}
if (printf("Hello, world!\n")) {}

If we want to call a function that returns void, we cannot use that trick, as void functions are not expressions. But it can be remedied using the not so famous comma operator, with any value in the right hand side of the operator.



>>>> constexpr

used while defining a function
increases compile time but reduces the run time 
ans is calculated at the compile time only  



>>>> constexpr vs inline functions

Both are for performance improvements, inline functions request 
compiler to expand at compile time and save time of 
function call overheads. In inline functions, expressions 
are always evaluated at run time. constexpr is different, 
here expressions are evaluated at compile time.



>>>> constexpr vs const

They serve different purposes. constexpr is mainly for optimization 
while const is for practically const objects like value of Pi.
Both of them can be applied to member methods. Member methods are 
made const to make sure that there are no accidental changes by 
the method. On the other hand, the idea of using constexpr is to 
compute expressions at compile time so that time can be saved when code is run.
const can only be used with non-static member function whereas 
constexpr can be used with member and non-member functions, even 
with constructors but with condition that argument and return type 
must be of literal types


.............................................................................
